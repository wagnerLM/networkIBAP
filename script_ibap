### Curso redes IBAP
#instalando os pacotes
install.packages("RCurl") #repetir para todos os pacotes ou 
#exemplo via https://gist.github.com/stevenworthington/3178163 
ipak <- function(pkg){
   new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
    if (length(new.pkg)) 
        install.packages(new.pkg, dependencies = TRUE)
    sapply(pkg, require, character.only = TRUE)
}

# usage
packages <- c("ggplot2", "plyr", "reshape2", "RColorBrewer", "scales", "grid")
ipak(packages)

#carregando os pacotes
library(RCurl)
library(IsingFit)
library(mgm)
library(semPlot)
library(lavaan)
library(psych)
library(lvnet)
library(NetworkComparisonTest)
library(igraph)
library(bootnet)
library(qgraph)
### Representação de dados psicométricos
data("big5")
View(big5)
qgraph(cor(big5))
data("big5groups")
#correlações por grupo
cor.plot(cor(big5))
Q<-qgraph(cor(big5),groups=big5groups)
Q<-qgraph(Q,minimum=0.25,borders=F,vsize=2)
#correlações sem grupo
qgraph(Q,layout="spring",legend=F)
#efa e pca
qgraph.efa(big5,5,groups=big5groups,rotation="promax",minimum=0.2,cut=0.4,vsize=c(1,15),borders=F,asize=0.07,esize=4,vTrans=200)
qgraph.pca(big5,5,groups=big5groups,rotation="promax",minimum=0.2,cut=0.4,vsize=c(1,15),borders=F,asize=0.07,esize=4,vTrans=200)
#cfa
big5_fit<-qgraph.cfa(cov(big5), N = nrow(big5), groups = big5groups,pkg="lavaan",opts=list(se="none"),fun=print)
qgraph(big5_fit)
### Redes gaussianas (GGM) - métodos de estimação  
#baseado em: http://psychosystems.org/network-model-selection-using-qgraph-1-3-10/
#exemplo BFI (banco do pacote psych)
bfi2<-getURL("https://raw.githubusercontent.com/wagnerLM/networkIBAP/master/bfi.csv")
bfi2<-read.csv(text = bfi2,sep=";")
View(bfi2)
#nomes e agrupamentos das variáveis
bfi2_names<-list("Am indifferent to the feelings of others","Inquire about others' well-being","Know how to comfort others","Love children","Make people feel at ease","Am exacting in my work","Continue until everything is perfect","Do things according to a plan","Do things in a half-way manner","Waste my time","Don't talk a lot","Find it difficult to approach others","Know how to captivate people","Make friends easily","Take charge","Get angry easily","Get irritated easily","Have frequent mood swings","Often feel blue","Panic easily","Am full of ideas","Avoid difficult reading material","Carry the conversation to a higher level","Spend time reflecting on things","Will not probe deeply into a subject","Gender(1=M,2=F)","education","age(years)")
bfi2_groups<-rep(c("A","C","E","N","O"),each=5)
#gerando a matriz de correlações
bfi2_cors<-cor_auto(bfi2[1:25]) #função do qgraph que escolhe o tipo correto de correlação conforme o nível de mensuração da variável
#visualizando a matriz de correlações
cor.plot(bfi2_cors)
#qgraph e estimação GGM
#cor graph
bfi2_corG<-qgraph(bfi2_cors,layout="spring",groups=bfi2_groups,title="correlation")
#pcor graph
bfi2_pcorG<-qgraph(bfi2_cors,layout=bfi2_corG$layout,groups=bfi2_groups,graph="pcor",title="partial correlation")
#holm graph
bfi2_holmG<-qgraph(bfi2_cors,layout=bfi2_corG$layout,groups=bfi2_groups,graph="pcor",threshold="holm",sampleSize=nrow(bfi),title="holm graph")
#optimal graph
bfi2_optmG<-findGraph(bfi2_cors,nrow(bfi),type="pcor")
bfi2_optimalG<-qgraph(bfi2_optmG,layout=bfi2_corG$layout,groups=bfi2_groups,labels=colnames(bfi2_cors),title="optimal graph")
par(mfrow=c(2,2))
plot(bfi2_corG)
plot(bfi2_pcorG)
plot(bfi2_holmG)
plot(bfi2_optimalG)
#lasso estimation
par(mfrow=c(1,1))
bfi2_glassoG<-qgraph(bfi2_cors,layout=bfi2_corG$layout,groups=bfi2_groups,graph="glasso",sampleSize=nrow(bfi),tuning=0.25,title="GeLasso")  #0.25 é o valor indicado para o hiperparâmetro gama
qgraph(bfi2_cors,layout="spring",groups=bfi2_groups,graph="glasso",sampleSize=nrow(bfi),tuning=0.25,title="GeLasso")
#índices de ajuste
bfi2_cov<-cov(bfi2,use = "pairwise.complete.obs")
bfi2_fit<-ggmFit(bfi2_glassoG,bfi2_cov,nrow(bfi2))
bfi2_fit$fitMeasures
#QSG - há debate sobre a dimensionalidade (1 ou 2 fatores?)
qsgb<-getURL("https://raw.githubusercontent.com/wagnerLM/networkIBAP/master/QSG.csv")
qsgb<-read.csv(text = qsgb,sep=";")
View(qsgb)
qsgc<-cor_auto(qsgb)
qsg_groups<-list("positivos"=c(1,3,4,7,8,12),"negativos"=c(2,5,6,9,10,11))
qsg_names<-list("Tem podido concentrar-se no que faz","Suas preocupações o fazem perder o sono","Tem sentido que tem papel útil na vida","Tem sido capaz de tomar decisões","Tem notado que está agoniado","Tem sensação de não superar dificuldades","Tem sido capaz de desfrutar de atividades","Tem sido capaz de enfrentar problemas","Tem se sentido pouco feliz e deprimido","Tem perdido confiança em si mesmo","Tem pensado que não serve para nada","Sente-se razoavelmente feliz")
qsg_G1<-qgraph(qsgc,layout="spring",groups=qsg_groups,nodeNames=qsg_names,legend.cex=0.26)
qsg_G2<-qgraph(qsgc,layout="spring",groups=qsg_groups,graph="glasso",sampleSize=nrow(qsgb),tuning=0.25,nodeNames=qsg_names,legend.cex=0.26)

### descritivos das redes
#medidas de centralidade - betweenness, closeness e strength
centralityPlot(list("cor"=bfi2_corG,"pcor"=bfi2_pcorG,"holm"=bfi2_holmG,"optimal"=bfi2_optimalG,"GeLasso"=bfi2_glassoG))
#shotest paths e shortest paths lengths
centralityPlot(list("cor"=qsg_G1,"GeLasso"=qsg_G2))
qsg_cent<-centrality(qsg_G2,all.shortest.paths = T)
str(qsg_cent)
View(qsg_cent$ShortestPathLengths)
View(qsg_cent$ShortestPaths)
pathways(qsg_G2,from="QSG02",to=c("QSG04","QSG08"),fading=0.25)
View(getWmat(qsg_G2))

### rede de dados dicotômicos
#modelo equivalente a TRI multidimensional de 2 parâmetros
library(IsingFit)
dass<-getURL("https://raw.githubusercontent.com/wagnerLM/networkIBAP/master/dassmgroup.csv")
dass<-read.csv(text = dass,sep=";")
View(dass)
dass_sub<-dass[2:22]
View(dass_sub)
namesdass<-list("1.wind","2.drymth","3.posfeel","4.breatdiff","5.init","6.ovreact","7.tremb","8.nervener","9.panfool","10.lookfor","11.gettagit","12.relax","13.blue","14.intol","15.panic","16.enthu","17.worth","18.rattouch","19.heartphys","20.scareas","21.meaning")
dass_groups<-list("stress"=c(1,6,8,11,12,14,18),"anxiety"=c(2,4,7,9,15,19,20),"depression"=c(3,5,10,13,16,17,21))
dass_cor<-cor_auto(dass_sub)
dass_glasso<-qgraph(dass_cor,layout="spring",graph="glasso",sampleSize=nrow(dass_sub),labels=colnames(dass_sub),groups=dass_groups,nodeNames=namesdass,legend.cex=0.3,palette="pastel")
dass_ising<-IsingFit(dass_sub,family = "binomial",AND=TRUE,gamma=0.25,plot = TRUE,progressbar = TRUE)
dassIsing<-qgraph(dass_ising$weiadj,layout="spring",groups=dass_groups,nodeNames=namesdass,legend.cex=0.3,palette="pastel")
centralityPlot(list("GeLasso"=dass_glasso,"Ising"=dassIsing))
dass_ising$thresholds
dass_thsld<-qgraph(dassIsing,vsize=(5+(dass_ising$thresholds))*2.3,labels=colnames(dass_sub))
dass_cent<-centrality(dass_thsld,all.shortest.paths = T)
View(dass_cent$ShortestPaths)
View(dass_ising$weiadj)

### mixed networks
library(MASS)
library(mgm)
#preparando os dados
smmix<-getURL("https://raw.githubusercontent.com/wagnerLM/networkIBAP/master/mixednet.csv")
smmix<-read.csv(text = smmix,sep=";")
smmix<-na.omit(smmix)
View(smmix)
#modelo de regressão linear enter e stepwise
fit_sm<-lm(smmix$SM~smmix$Id+smmix$Sex+smmix$Esc+smmix$Atv+smmix$Ric
             +smmix$Rend+smmix$Tvol+smmix$Pre+smmix$SG+smmix$EP,data=smmix)
summary(fit_sm)
step <- stepAIC(fit_sm, direction="both")
step$anova
#preparando mixed network
type<-c("g","c","c","c","c","g","c","c","g","g","g")
level<-c(1,2,3,3,2,1,2,2,1,1,1)
str(type)
str(level)
smfit<-mgmfit(smmix,type=type,lev=level,gam =0.25,rule.reg = "OR")
#visualizando os resultados no qgraph
qgraph(smfit$wadj,layout="spring",fade=F,labels=colnames(smmix),edge.labels=T)
#comparando com o GGM dos mesmos dados
smmix_c<-cor_auto(smmix)
qgraph(smmix_c,layout="spring",fade=F,labels=colnames(smmix),edge.labels=T,graph="glasso",sampleSize=nrow(smmix),tuning=0.25)
#dados de autismo, fornecido como exemplo pelo pacote 
data(autism_data)
View(autism_data)
fit_aut <- mgmfit(data = autism_data$data,type = autism_data$type,lev = autism_data$lev,lambda.sel = 'EBIC')
colnames(fit_aut$wadj) <- autism_data$colnames
autism_g<-qgraph(fit_aut$wadj,legend=TRUE,nodeNames=autism_data$colnames,layout='spring',legend.cex=0.5)

### análise de comunidades - identificando subgrupos em uma rede
#análise de counidades do BFI
# transformar em objeto igraph
bfi2_glassoIG<-as.igraph(bfi2_glassoG)
#walktrap community
bfi_wtc<-walktrap.community(bfi2_glassoIG)
bfi_wtc$membership
qgraph(bfi2_glassoG,groups=as.factor(bfi_wtc$membership),labels=colnames(bfi2))
#spinglass community
bfi_sgc<-spinglass.community(bfi2_glassoIG)
bfi_sgc$membership
qgraph(bfi2_glassoG,groups=as.factor(bfi_sgc$membership),labels=colnames(bfi2))
#louvain community - não aceita arestas negativas!
#preparação - removendo as arestas negativas
bfi2_glassoG2<-qgraph(abs(getWmat(bfi2_glassoG)),layout="spring")
bfi2_glassoIG2<-as.igraph(bfi2_glassoG2)
#método louvain
bfi_lvc<-cluster_louvain(bfi2_glassoIG2)
bfi_lvc$membership
qgraph(bfi2_glassoG,groups=as.factor(bfi_lvc$membership),labels=colnames(bfi2))
#análise de comunidades do QSG 
plot(qsg_G2)
qsg_IG2<-as.igraph(qsg_G2)
qsg_wtc<-walktrap.community(qsg_IG2)  
qsg_wtc$membership
qsg_sgc<-spinglass.community(qsg_IG2)
qsg_sgc$membership
qsg_G2_2<-qgraph(abs(getWmat(qsg_G2)),layout="spring")
qsg_IG2_2<-as.igraph(qsg_G2_2)
qsg_lvc<-cluster_louvain(qsg_IG2_2)
qsg_lvc$membership
qgraph(qsg_G2,groups=as.factor(qsg_lvc$membership))
#exemplo com a DASS-21, comunidades
plot(dass_glasso)
dass_iglasso<-as.igraph(dass_glasso)
dass_glasso_wtc<-walktrap.community(dass_iglasso)
dass_glasso_wtc
dass_glasso_sgc<-spinglass.community(dass_iglasso)
dass_glasso_sgc

plot(dassIsing)
dassIsing_ig<-as.igraph(dassIsing)
dass_ising_wtc<-walktrap.community(dassIsing_ig)
dass_ising_wtc
dass_ising_sgc<-spinglass.community(dassIsing_ig)
dass_ising_sgc
#método Ising recupera os agrupamentos teoricamente esperados
#o método Louvain recupera a estrutura na aproximação não paramétrica do grafo gaussiano?
dass_lv_g<-qgraph(abs(getWmat(dass_glasso)),layout="spring")
dass_lv_ig<-as.igraph(dass_lv_g)
walktrap.community(dass_lv_ig) #2 comunidades
spinglass.community(dass_lv_ig) #4 comunidades
cluster_louvain(dass_lv_ig) #3 comunidades modificado
#bad news... 
# comunidades preditores da satisfação com tratamento, no estudo do autismo
autism_ig<-as.igraph(autism_g)
aut_wtc<-walktrap.community(autism_ig) # os métodos louvain e spinglass recuperam os mesmos resultados
qgraph(fit_aut$wadj,legend=TRUE,nodeNames=autism_data$colnames,layout='spring',groups=as.factor(aut_wtc$membership),palette="pastel",legend.cex=0.3)
# os métodos louvain e spinglass recuperam os mesmos resultados

### Network comparison
#permite comparar redes de acordo com 3 medidas: invariância estrutural, invariãncia da força global e invariância de arestas
#preparação dos bancos
dass_m<-dass[2:22][ which(dass$gender== 1),]
View(dass_m)
dass_f<-dass[2:22][ which(dass$gender== 2),]
View(dass_f)
# Network comparison test
dass_nct<-NCT(dass_f, dass_m, gamma=0.25, it=10, binary.data=TRUE, paired=FALSE, 
              weighted=TRUE, AND=TRUE, test.edges=TRUE, edges="all", 
              progressbar=TRUE)
#invariância estrutural
dass_nct$nwinv.real 
dass_nct$nwinv.perm 
dass_nct$nwinv.pval 
#força global
dass_nct$glstrinv.sep 
dass_nct$glstrinv.real 
dass_nct$glstrinv.perm
dass_nct$glstrinv.pval 
#arestas 
dass_nct$einv.real
dass_nct$einv.pvals
#plotando ambos os grafos
par(mfrow=c(1,2))
#masculino
dassm_ising<-IsingFit(dass_m,family = "binomial",AND=TRUE,gamma=0.25,plot = TRUE,progressbar = TRUE)
dassIsing_m<-qgraph(dassm_ising$weiadj,layout=dassIsing$layout,groups=dass_groups,nodeNames=namesdass,legend.cex=0.3,palette="pastel",legend=F,title="Masc")
#feminino
dassf_ising<-IsingFit(dass_f,family = "binomial",AND=TRUE,gamma=0.25,plot = TRUE,progressbar = TRUE)
dassIsing_f<-qgraph(dassf_ising$weiadj,layout=dassIsing$layout,groups=dass_groups,nodeNames=namesdass,legend.cex=0.3,palette="pastel",legend=F,title="Fem")
# edges 3 e 4 
pathways(dassIsing_m,from = "DASS3",to="DASS4",fading = 0.8)
pathways(dassIsing_f,from = "DASS3",to="DASS4",fading = 0.8)
#edges 4 e 8
pathways(dassIsing_m,from = "DASS8",to="DASS4",fading = 0.8)
pathways(dassIsing_f,from = "DASS8",to="DASS4",fading = 0.8)
par(mfrow=c(1,1))

### estabilidade das redes
mhc<-getURL("https://raw.githubusercontent.com/wagnerLM/networkIBAP/master/MHC-SF.csv")
mhc<-read.csv(text = mhc,sep=";")
View(mhc)
mhc_c<-cor_auto(mhc)
mhc_g<-qgraph(mhc_c,layout="spring",graph="glasso",sampleSize=nrow(mhc),tuning=0.25)
?estimateNetwork
Network <- estimateNetwork(mhc, default = "EBICglasso",tuning=0.25,corMethod="cor_auto",labels=colnames(mhc))
plot(Network,layout="spring",labels=T)
boot1<-bootnet(Network,nBoots=20,nCores = 8)
plot(boot1, labels = FALSE, order = "sample")
boot2 <- bootnet(Network, nBoots = 20, type = "case", nCores = 8)
plot(boot2)
corStability(boot2)
differenceTest(boot1, 3, 14, "strength")
plot(boot1, "edge", plot = "difference", onlyNonZero = TRUE,order = "sample")
plot(boot1, "betweenness")
plot(boot1)

### predição
mhc<-getURL("https://raw.githubusercontent.com/wagnerLM/networkIBAP/master/MHC-SF.csv")
mhc<-read.csv(text = mhc,sep=";")
View(mhc)
p<-ncol(mhc)
dim(mhc)
fit_mhc<-mgmfit(mhc,type = rep("g",p),lev=rep(1,p),rule.reg = "OR")
pred_mhc<-predict(fit_mhc,mhc,error.continuous = "VarExpl")
pred_mhc$error
mean(pred_mhc$error$Error)
qgraph(fit_mhc$wadj,layout="spring",pie=pred_mhc$error$Error,labels=colnames(mhc))

### lv networks
#BFI lvnetwork
bfi_lvnet<-EBIClvglasso(bfi2_cors,nrow(bfi2),5,gamma = 0.25,nRho = 100)
plot(bfi_lvnet,"network")
bfi_lvg<-qgraph(bfi_lvnet$pcor,layout="spring")
bfi_fit<-ggmFit(bfi_lvg,bfi_lvnet$w,nrow(bfi2),ebicTuning = 0.25,refit = F)
bfi_fit
bfiWadj<-getWmat(bfi_lvg)
View(bfiWadj[c(26:30),c(26:30)])
#lvneet QSG
#lv net com 1 fator
qsg_lv1<-EBIClvglasso(qsgc,nrow(qsgb),1,gamma = 0.25,nRho = 100)
plot(qsg_lv1,"network")
qsg_lvg1<-qgraph(qsg_lv1$pcor,layout="spring")
#lv net com 2 fatores
qsg_lv2<-EBIClvglasso(qsgc,nrow(qsgb),2,gamma = 0.25,nRho = 100)
plot(qsg_lv2,"network")
qsg_lvg2<-qgraph(qsg_lv2$pcor,layout="spring")
#matriz de covariância
qsg_cov<-cov(qsgb,use = "pairwise.complete.obs")
View(qsg_cov)
#estimando o ajuste dos modelos
qsg_fit1<-ggmFit(qsg_lvg1,qsg_lv1$w,nrow(qsgb),ebicTuning = 0.25,refit = F)
qsg_fit1$fitMeasures
qsg_fit2<-ggmFit(qsg_lvg2,qsg_lv2$w,nrow(qsgb),ebicTuning = 0.25,refit = F)
qsg_fit2$fitMeasures
